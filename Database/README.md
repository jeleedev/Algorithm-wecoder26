# Database
- [트리거(Trigger)란?](#%EF%B8%8F-트리거trigger란)
- [트랜잭션(Transaction)이란?](#%EF%B8%8F-트랜잭션transaction이란)
- [조인(Join)이란?](#%EF%B8%8F-조인join이란)

<br>

## 💡️ 트리거(Trigger)란?
> 테이블에 삽입, 수정, 삭제 등의 데이터 변경 이벤트가 발생하면 이벤트에 반응하여 다른 명령을 자동적으로 실행되도록 하는 기능이다.
> 이벤트는 전체 트랜잭션 대상과 각행에 의해 발생되는 경우 모두를 포함하며 테이블과 뷰(View), DB작업을 대상으로 한다.

<br>

## 💡️ 트랜잭션(Transaction)이란?
> 트랜잭션(Transaction)은 데이터베이스 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 수행되어야 할 일련의 연산들을 의미한다.
> 만약 논리적인 작업을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 작업의 안정성을 보장해주는 기능이다.

<br>

### 트랜잭션의 특성
> 트랜잭션은 원자성, 일관성, 독립성, 영속성 총 4가지이며 줄여서 ACID라고도 한다.

- 원자성(Atomicity)
: 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.

- 일관성(Consistency)
: 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다. 트랜잭션이 진행되는 동안에 데이터베이스가 변경되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는 것이 아니라, 처음에 트랜잭션을 진행하기 위해 참조한 데이터베이스로 진행된다. 이렇게 함으로써 각 사용자들은 일관성 있는 데이터를 볼 수 있다.

- 독립성(Isolation)
: 트랜잭션이 실행되고 있을 때, 다른 트랜잭션의 연산작업이 중간에 끼어들지 못하게 하여 기존 작업에 영향을 주지 못하도록 한다. 실행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 결과를 참조할 수 없다.

- 영속성(Durablility)
: 성공적으로 실행된 트랜잭션은 데이터베이스에 영구적으로 반영되어야 한다.

<br>

### 트랜잭션의 상태
- 활동(Active)
: 트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태.

- 실패(Failed)
: 트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행할 수 없는 상태.

- 부분 완료(Partially Committed)
: 트랜잭션의 Commit 명령이 도착한 상태. 트랜잭션의 commit이전 sql문이 수행되고 commit만 남은 상태.

- 철회(Aborted)
: 트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태.

- 완료(Committed)
: 트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태

<img width="769" alt="트랜잭션 상태" src="https://user-images.githubusercontent.com/89324683/148967853-bf44f657-7452-42c1-b879-37dc1f2568c3.png">

<br>

### Partially Committed 와 Committed 의 차이점
> Commit 요청이 들어오면 상태는 Partial Commited 상태가 된다. 이후 Commit을 문제없이 수행할 수 있으면 Committed 상태로 전이되고, 만약 오류가 발생하면 Failed 상태가 된다. 즉, Partial Commited는 Commit 요청이 들어왔을 때를 말하며, Commited는 Commit을 정상적으로 완료한 상태를 말한다.

<br>

### 트랜잭션을 사용할 때 주의할 점
> 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉 트랜잭션의 범위를 최소화하라는 것. 일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 되고 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있다.

  **독립성과 무결성**
  > 독립성을 보장하기 위해 모든 트랜잭션을 순차적으로 실행한다면 동시성 처리 이슈가 발생할 수 있다.
  > 반대로 동시성 처리를 높이기 위해 트랜잭션을 병렬처리하게 되면 데이터의 무결성이 깨질 수 있다.

  1. Dirty Read
  > 한 트랜잭션(T1)이 데이터에 접근해서 A라는 값을 B로바꾸고 커밋하지 않았을때, 다른 트랜잭션(T2)이 같은 데이터에 접근하여 데이터를 READ하면 T2가 읽은 데이터는 B가 된다. T1이 커밋을 실패하게 된다면 T2의 데이터는 망가지게 된다.

  2. Non-Repeatable Read
  > 한 트랜잭션(T1)이 데이터를 Read하고 있을때 다른 트랜잭션(T2)가 T1이 접근하는 데이터를 변경 혹은 삭제한다면 T1은 사라진 데이터 혹은 변경된 데이터를 찾게 된다.

  3. Phantom Read
  > 트랜잭션(T1)이 특정 조건으로 데이터를 검색하여 결과를 얻었을때, 다른 트랜잭션(T2)가 접근해 해당 조건의 데이터를 일부 삭제 혹은 추가했을때, 아직 끝나지 않은 T1 트랜잭션이 다시 해당조건으로 데이터를 조회하면 T2에서 추가/삭제한 데이터가 함께 조회/누락 된다. 이후 T2가 롤백을 하게된다면 데이터가 꼬이게 된다.

<br>

## 💡️ 조인(Join)이란?
> 조인에 기반한 둘 이상의 테이블 컬럼값을 결합하여 새로운 결과 테이블을 생성한다.
> 둘 이상의 테이블을 연결해서 데이터를 검색하는 방법으로 조인을 하려면 테이블들이 적어도 하나의 컬럼을 공유하고 있어야 하며 해당 컬럼을 PK 또는 FK 값으로 사용한다.
<img width="649" alt="스크린샷 2022-01-12 오전 12 09 31" src="https://user-images.githubusercontent.com/89324683/148968408-b32187f4-c18b-4528-a5ea-30aab277007b.png">
<br>

### Join의 필요성
- 관계형 데이터베이스의 구조적 특징으로 정규화를 수행하면 의미 있는 데이터의 집합으로 테이블이 구성되고, 각 테이블끼리는 관계(Relationship)를 갖게 된다. 이와 같은 특징으로 관계형 데이터베이스는 저장 공간의 효율성과 확장성이 향상되게 된다.
- 서로 관계있는 데이터가 여러 테이블로 나뉘어 저장되므로, 각 테이블에 저장된 데이터를 효과적으로 검색하기 위해 조인이 필요하다.

<br>

### Join의 종류
1. 내부조인(Inner Join)
> 가장 흔한 결합 방식이며 기본 조인 형식으로 간주된다.
> 내부 조인은 기준 테이블과 조인 테이블 모두 데이터가 존재해야 조회된다. 두 테이블에 교집합되는 내용만 확인되는 것.
![Join](https://user-images.githubusercontent.com/89324683/148970008-2eedfa76-a619-4fbc-aff3-12a1c33a2f79.png)

2. 외부조인(Outer Join)
> 기준 테이블과 조인 테이블에 데이터가 모두 있지 않아도 기준 테이블에 컬럼이 있을 경우 모두 확인할 수 있다.
> 외부 조인을 사용하는 이유는 기준 테이블의 데이터를 누락없이 모두 조회하고 참조 테이블의 값이 있을 경우 해당 값을 사용하기 위해서다.

- Left Join
> 조인 기준 왼쪽 테이블 있는 모든 데이터를 포함한다.

- Right Join
> 조인 기준 오른쪽 테이블에 있는 모든 데이터를 포함한다.

- Full Outer Join
> 두 테이블의 모든 데이터를 포함한다.